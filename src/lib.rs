#![doc = "Peripheral access API for PSOC4100S microcontrollers (generated using svd2rust v0.24.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.24.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![deny(const_err)]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn IOSS_INTERRUPTS_GPIO_0();
    fn IOSS_INTERRUPTS_GPIO_1();
    fn IOSS_INTERRUPTS_GPIO_2();
    fn IOSS_INTERRUPTS_GPIO_3();
    fn IOSS_INTERRUPT_GPIO();
    fn LPCOMP_INTERRUPT();
    fn SRSS_INTERRUPT_WDT();
    fn SCB_0_INTERRUPT();
    fn SCB_1_INTERRUPT();
    fn SCB_2_INTERRUPT();
    fn PASS_0_INTERRUPT_CTBS();
    fn WCO_INTERRUPT();
    fn CPUSS_INTERRUPT_SPCIF();
    fn CSD_INTERRUPT();
    fn TCPWM_INTERRUPTS_0();
    fn TCPWM_INTERRUPTS_1();
    fn TCPWM_INTERRUPTS_2();
    fn TCPWM_INTERRUPTS_3();
    fn TCPWM_INTERRUPTS_4();
    fn PASS_0_INTERRUPT_SAR();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 20] = [
    Vector {
        _handler: IOSS_INTERRUPTS_GPIO_0,
    },
    Vector {
        _handler: IOSS_INTERRUPTS_GPIO_1,
    },
    Vector {
        _handler: IOSS_INTERRUPTS_GPIO_2,
    },
    Vector {
        _handler: IOSS_INTERRUPTS_GPIO_3,
    },
    Vector {
        _handler: IOSS_INTERRUPT_GPIO,
    },
    Vector {
        _handler: LPCOMP_INTERRUPT,
    },
    Vector {
        _handler: SRSS_INTERRUPT_WDT,
    },
    Vector {
        _handler: SCB_0_INTERRUPT,
    },
    Vector {
        _handler: SCB_1_INTERRUPT,
    },
    Vector {
        _handler: SCB_2_INTERRUPT,
    },
    Vector {
        _handler: PASS_0_INTERRUPT_CTBS,
    },
    Vector {
        _handler: WCO_INTERRUPT,
    },
    Vector {
        _handler: CPUSS_INTERRUPT_SPCIF,
    },
    Vector {
        _handler: CSD_INTERRUPT,
    },
    Vector {
        _handler: TCPWM_INTERRUPTS_0,
    },
    Vector {
        _handler: TCPWM_INTERRUPTS_1,
    },
    Vector {
        _handler: TCPWM_INTERRUPTS_2,
    },
    Vector {
        _handler: TCPWM_INTERRUPTS_3,
    },
    Vector {
        _handler: TCPWM_INTERRUPTS_4,
    },
    Vector {
        _handler: PASS_0_INTERRUPT_SAR,
    },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - GPIO P0"]
    IOSS_INTERRUPTS_GPIO_0 = 0,
    #[doc = "1 - GPIO P1"]
    IOSS_INTERRUPTS_GPIO_1 = 1,
    #[doc = "2 - GPIO P2"]
    IOSS_INTERRUPTS_GPIO_2 = 2,
    #[doc = "3 - GPIO P3"]
    IOSS_INTERRUPTS_GPIO_3 = 3,
    #[doc = "4 - GPIO All Ports"]
    IOSS_INTERRUPT_GPIO = 4,
    #[doc = "5 - LPCOMP trigger interrupt"]
    LPCOMP_INTERRUPT = 5,
    #[doc = "6 - WDT"]
    SRSS_INTERRUPT_WDT = 6,
    #[doc = "7 - SCB #0"]
    SCB_0_INTERRUPT = 7,
    #[doc = "8 - SCB #1"]
    SCB_1_INTERRUPT = 8,
    #[doc = "9 - SCB #2"]
    SCB_2_INTERRUPT = 9,
    #[doc = "10 - CTBm Interrupt (all CTBms)"]
    PASS_0_INTERRUPT_CTBS = 10,
    #[doc = "11 - WCO WDT Interrupt"]
    WCO_INTERRUPT = 11,
    #[doc = "12 - SPCIF interrupt"]
    CPUSS_INTERRUPT_SPCIF = 12,
    #[doc = "13 - CSD #0 (Primarily Capsense)"]
    CSD_INTERRUPT = 13,
    #[doc = "14 - TCPWM #0, Counter #0"]
    TCPWM_INTERRUPTS_0 = 14,
    #[doc = "15 - TCPWM #0, Counter #1"]
    TCPWM_INTERRUPTS_1 = 15,
    #[doc = "16 - TCPWM #0, Counter #2"]
    TCPWM_INTERRUPTS_2 = 16,
    #[doc = "17 - TCPWM #0, Counter #3"]
    TCPWM_INTERRUPTS_3 = 17,
    #[doc = "18 - TCPWM #0, Counter #4"]
    TCPWM_INTERRUPTS_4 = 18,
    #[doc = "19 - SAR"]
    PASS_0_INTERRUPT_SAR = 19,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Peripheral Interconnect"]
pub struct PERI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PERI {}
impl PERI {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const peri::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const peri::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PERI {
    type Target = peri::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PERI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PERI").finish()
    }
}
#[doc = "Peripheral Interconnect"]
pub mod peri;
#[doc = "High Speed IO Matrix (HSIOM)"]
pub struct HSIOM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HSIOM {}
impl HSIOM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hsiom::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hsiom::RegisterBlock {
        Self::PTR
    }
}
impl Deref for HSIOM {
    type Target = hsiom::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HSIOM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HSIOM").finish()
    }
}
#[doc = "High Speed IO Matrix (HSIOM)"]
pub mod hsiom;
#[doc = "System Resources Lite Subsystem"]
pub struct SRSSLT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SRSSLT {}
impl SRSSLT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const srsslt::RegisterBlock = 0x4003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const srsslt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SRSSLT {
    type Target = srsslt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SRSSLT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SRSSLT").finish()
    }
}
#[doc = "System Resources Lite Subsystem"]
pub mod srsslt;
#[doc = "GPIO port control/configuration"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO").finish()
    }
}
#[doc = "GPIO port control/configuration"]
pub mod gpio;
#[doc = "Programmable IO configuration"]
pub struct PRGIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PRGIO {}
impl PRGIO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const prgio::RegisterBlock = 0x4005_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const prgio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PRGIO {
    type Target = prgio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PRGIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PRGIO").finish()
    }
}
#[doc = "Programmable IO configuration"]
pub mod prgio;
#[doc = "Timer/Counter/PWM"]
pub struct TCPWM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TCPWM {}
impl TCPWM {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tcpwm::RegisterBlock = 0x4006_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tcpwm::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TCPWM {
    type Target = tcpwm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TCPWM {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TCPWM").finish()
    }
}
#[doc = "Timer/Counter/PWM"]
pub mod tcpwm;
#[doc = "32KHz Oscillator"]
pub struct WCO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WCO {}
impl WCO {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wco::RegisterBlock = 0x4007_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wco::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WCO {
    type Target = wco::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WCO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WCO").finish()
    }
}
#[doc = "32KHz Oscillator"]
pub mod wco;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct SCB0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SCB0 {}
impl SCB0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SCB0 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SCB0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCB0").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub mod scb0;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct SCB1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SCB1 {}
impl SCB1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4009_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SCB1 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SCB1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCB1").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use scb0 as scb1;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct SCB2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SCB2 {}
impl SCB2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x400a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SCB2 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SCB2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCB2").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use scb0 as scb2;
#[doc = "LCD Controller Block"]
pub struct LCD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LCD {}
impl LCD {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lcd::RegisterBlock = 0x400b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lcd::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LCD {
    type Target = lcd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LCD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LCD").finish()
    }
}
#[doc = "LCD Controller Block"]
pub mod lcd;
#[doc = "Capsense Controller"]
pub struct CSD0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CSD0 {}
impl CSD0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const csd0::RegisterBlock = 0x400c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const csd0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CSD0 {
    type Target = csd0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CSD0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CSD0").finish()
    }
}
#[doc = "Capsense Controller"]
pub mod csd0;
#[doc = "Low Power Comparators"]
pub struct LPCOMP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LPCOMP {}
impl LPCOMP {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lpcomp::RegisterBlock = 0x400d_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lpcomp::RegisterBlock {
        Self::PTR
    }
}
impl Deref for LPCOMP {
    type Target = lpcomp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LPCOMP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LPCOMP").finish()
    }
}
#[doc = "Low Power Comparators"]
pub mod lpcomp;
#[doc = "CPU Subsystem"]
pub struct CPUSS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CPUSS {}
impl CPUSS {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpuss::RegisterBlock = 0x4010_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpuss::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CPUSS {
    type Target = cpuss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CPUSS {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CPUSS").finish()
    }
}
#[doc = "CPU Subsystem"]
pub mod cpuss;
#[doc = "Flash Control Interface"]
pub struct SPCIF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPCIF {}
impl SPCIF {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spcif::RegisterBlock = 0x4011_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spcif::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPCIF {
    type Target = spcif::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPCIF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPCIF").finish()
    }
}
#[doc = "Flash Control Interface"]
pub mod spcif;
#[doc = "Continuous Time Block Mini"]
pub struct CTBM0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CTBM0 {}
impl CTBM0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ctbm0::RegisterBlock = 0x4030_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ctbm0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CTBM0 {
    type Target = ctbm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CTBM0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CTBM0").finish()
    }
}
#[doc = "Continuous Time Block Mini"]
pub mod ctbm0;
#[doc = "SAR ADC with Sequencer"]
pub struct SAR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SAR0 {}
impl SAR0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sar0::RegisterBlock = 0x403a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sar0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SAR0 {
    type Target = sar0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SAR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SAR0").finish()
    }
}
#[doc = "SAR ADC with Sequencer"]
pub mod sar0;
#[doc = "PASS top-level MMIO (DSABv2, INTR)"]
pub struct PASS0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PASS0 {}
impl PASS0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pass0::RegisterBlock = 0x403f_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pass0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PASS0 {
    type Target = pass0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PASS0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PASS0").finish()
    }
}
#[doc = "PASS top-level MMIO (DSABv2, INTR)"]
pub mod pass0;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PERI"]
    pub PERI: PERI,
    #[doc = "HSIOM"]
    pub HSIOM: HSIOM,
    #[doc = "SRSSLT"]
    pub SRSSLT: SRSSLT,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "PRGIO"]
    pub PRGIO: PRGIO,
    #[doc = "TCPWM"]
    pub TCPWM: TCPWM,
    #[doc = "WCO"]
    pub WCO: WCO,
    #[doc = "SCB0"]
    pub SCB0: SCB0,
    #[doc = "SCB1"]
    pub SCB1: SCB1,
    #[doc = "SCB2"]
    pub SCB2: SCB2,
    #[doc = "LCD"]
    pub LCD: LCD,
    #[doc = "CSD0"]
    pub CSD0: CSD0,
    #[doc = "LPCOMP"]
    pub LPCOMP: LPCOMP,
    #[doc = "CPUSS"]
    pub CPUSS: CPUSS,
    #[doc = "SPCIF"]
    pub SPCIF: SPCIF,
    #[doc = "CTBM0"]
    pub CTBM0: CTBM0,
    #[doc = "SAR0"]
    pub SAR0: SAR0,
    #[doc = "PASS0"]
    pub PASS0: PASS0,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            PERI: PERI {
                _marker: PhantomData,
            },
            HSIOM: HSIOM {
                _marker: PhantomData,
            },
            SRSSLT: SRSSLT {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            PRGIO: PRGIO {
                _marker: PhantomData,
            },
            TCPWM: TCPWM {
                _marker: PhantomData,
            },
            WCO: WCO {
                _marker: PhantomData,
            },
            SCB0: SCB0 {
                _marker: PhantomData,
            },
            SCB1: SCB1 {
                _marker: PhantomData,
            },
            SCB2: SCB2 {
                _marker: PhantomData,
            },
            LCD: LCD {
                _marker: PhantomData,
            },
            CSD0: CSD0 {
                _marker: PhantomData,
            },
            LPCOMP: LPCOMP {
                _marker: PhantomData,
            },
            CPUSS: CPUSS {
                _marker: PhantomData,
            },
            SPCIF: SPCIF {
                _marker: PhantomData,
            },
            CTBM0: CTBM0 {
                _marker: PhantomData,
            },
            SAR0: SAR0 {
                _marker: PhantomData,
            },
            PASS0: PASS0 {
                _marker: PhantomData,
            },
        }
    }
}
